Feature: Secure Text Field and Keyboard Handling

  Scenario: User enters text in secure field and verifies masking
    Given the app is launched
    When the user enters "password123" in the secure text field
    Then the secure text field should mask the entered text

  Scenario: User dismisses the keyboard by tapping outside
    Given the app is launched
    When the user enters "password123" in the secure text field
    And the user taps outside the secure text field to dismiss the keyboard
    Then the keyboard should be dismissed

  Scenario: User dismisses the keyboard by pressing the return key
    Given the app is launched
    When the user enters "password123" in the secure text field
    And the user presses the return key on the keyboard
    Then the keyboard should be dismissed

  Scenario: User edits text in the middle of the secure text field
    Given the app is launched
    When the user enters "password123" into the secure text field
    And the user replaces the character at position 5 with "X"
    Then the secure text field should display "passXord123"
    And the input should remain masked

import { Given, When, Then } from '@wdio/cucumber-framework';
import SecureTextPage from '../../pages/secureTextPage';

Given('the app is launched', async () => {
    await SecureTextPage.waitForAppToLoad();
});

When('the user enters {string} in the secure text field', async (text: string) => {
    await SecureTextPage.enterSecureText(text);
});

When('the user taps outside the secure text field to dismiss the keyboard', async () => {
    await SecureTextPage.tapOutsideToDismissKeyboard();
});

When('the user presses the return key on the keyboard', async () => {
    await SecureTextPage.pressReturnKey();
});

When('the user replaces the character at position {int} with {string}', async (position: number, newChar: string) => {
    await SecureTextPage.replaceCharacterAtPosition(position, newChar);
});

Then('the secure text field should mask the entered text', async () => {
    await SecureTextPage.verifySecureTextMasking();
});

Then('the keyboard should be dismissed', async () => {
    await SecureTextPage.verifyKeyboardDismissed();
});

Then('the secure text field should display {string}', async (expectedText: string) => {
    const actualText = await SecureTextPage.getSecureText();
    if (actualText !== expectedText) {
        throw new Error(`Expected text to be "${expectedText}" but found "${actualText}"`);
    }
});

Then('the input should remain masked', async () => {
    await SecureTextPage.verifySecureTextMasking();
});


import { ChainablePromiseElement } from 'webdriverio';
import { driver } from '@wdio/globals';

class SecureTextPage {
    /**
     * Define selectors using getter methods
     */
    private get secureTextField(): ChainablePromiseElement<WebdriverIO.Element> {
        return $('~secureTextField'); // Accessibility ID for cross-platform compatibility
    }

    private get dismissArea(): ChainablePromiseElement<WebdriverIO.Element> {
        return $('~dismissArea'); // Accessibility ID for the area to tap and dismiss the keyboard
    }

    /**
     * Wait for the application to load
     */
    public async waitForAppToLoad(): Promise<void> {
        await this.secureTextField.waitForDisplayed({ timeout: 10000 });
    }

    /**
     * Enter text into the secure text field
     * @param text The text to enter
     */
    public async enterSecureText(text: string): Promise<void> {
        await this.secureTextField.setValue(text);
    }

    /**
     * Tap outside the secure text field to dismiss the keyboard
     */
    public async tapOutsideToDismissKeyboard(): Promise<void> {
        await this.dismissArea.click();
    }

    /**
     * Press the return key on the keyboard
     */
    public async pressReturnKey(): Promise<void> {
        const platform = await driver.getPlatformName();
        if (platform === 'Android') {
            await driver.pressKeyCode(66); // KeyEvent for 'Enter' key on Android
        } else if (platform === 'iOS') {
            await driver.execute('mobile: performEditorAction', { action: 'return' });
        }
    }

    /**
     * Replace a character at a specific position in the secure text field
     * @param position The position (0-based index) of the character to replace
     * @param newChar The new character to insert
     */
    public async replaceCharacterAtPosition(position: number, newChar: string): Promise<void> {
        const currentValue = await this.secureTextField.getValue();
        const newValue = currentValue.substring(0, position) + newChar + currentValue.substring(position + 1);
        await this.secureTextField.setValue(newValue);
    }

    /**
     * Verify that the secure text field masks the entered text
     */
    public async verifySecureTextMasking(): Promise<void> {
        const isSecure = await this.secureTextField.getAttribute('secure');
        if (!isSecure) {
            throw new Error('The secure text field is not masking the input.');
        }
    }

    /**
     * Verify that the keyboard is dismissed
     */
    public async verifyKeyboardDismissed(): Promise<void> {
        const isKeyboardShown = await driver.isKeyboardShown();
        if (isKeyboardShown) {
            throw new Error('The keyboard is still visible.');
        }
    }

    /**
     * Get the current value of the secure text field
     * @returns The current text in the secure text field
     */
    public async getSecureText(): Promise<string> {
        return this.secureTextField.getValue();
    }
}

export default new SecureTextPage();



